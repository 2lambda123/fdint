# Copyright (c) 2015, Scott J Maddox. All rights reserved.
# Use of this source code is governed by the BSD-3-Clause
# license that can be found in the LICENSE file.
'''
Uses numerical integration to calculate accurate values to test against.

This should only be run after `python setup.py build_ext --inplace`.
'''

import os
import sys
sys.path.insert(0,
    os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
import fdint
tests_dir = os.path.join(os.path.dirname(__file__), '../fdint/tests/')

import warnings
import numpy
from numpy import exp, sqrt
from scipy.integrate import quad

INV_SQRT_PI_2 = 1.1283791670955126 # 2/sqrt(pi)

def quad_nonparabolic(phi, alpha):
    def func(x):
        return sqrt(x*(1+alpha*x))*(1+2*alpha*x)/(1.+exp(x-phi))*INV_SQRT_PI_2
    r = quad(func, 0, numpy.inf,epsabs=1e-300,epsrel=1e-13,limit=100)
    return r[0], r[1]

# phis = numpy.array([-50,-3,-2,-1,0,1,4,5,7,10,15,20,30,40,50], dtype=float)
phis = numpy.linspace(-50, 50, 101, dtype=float)

def write_header(f, modname, dependencies=''):
    f.write("""# Copyright (c) 2015, Scott J Maddox. All rights reserved.
# Use of this source code is governed by the BSD-3-Clause
# license that can be found in the LICENSE file.

# This file was generated by `scripts/gen_test_scfd.py`.
# Do not edit this file directly, or your changes will be lost.
'''
Tests the `{modname}` module.
'''
# Make sure we import the local package
import os
import sys
sys.path.insert(0,
    os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))
from fdint import {modname}
import unittest
import numpy
import warnings
""".format(modname=modname))
    f.write(dependencies)
    f.write('\n')
    f.write('class Test_{modname}(unittest.TestCase):\n'
            ''.format(modname=modname.upper()))
    f.write('''
    def assert_rtol(self, a, b, rtol):
        assert rtol >= 0
        rerr = abs(a-b)/a
        if rerr > rtol:
            self.fail('Outside of relative tolerance of {}: {}'
                      ''.format(rtol, rerr))
''')
    f.write('''
    def assert_all_rtol(self, a, b, rtol):
        assert (rtol >= 0).all()
        a = numpy.array(a)
        b = numpy.array(b)
        rtol = numpy.array(rtol)
        rerr = abs(a-b)/a
        if (rerr > rtol).all():
            self.fail('Outside of relative tolerance of {}: {}'
                      ''.format(rtol, rerr))
''')

##################
# Test scfd module
modname='scfd'
alphas = numpy.linspace(0., 0.15, 5)
fpath = os.path.join(tests_dir, 'test_{modname}.py'.format(modname=modname))
with open(fpath, 'w') as f:
    mod = getattr(fdint, modname)
    write_header(f, modname)
    fname = 'nonparabolic'
    # scalar
    i = 0
    for alpha in alphas:
        for phi in phis:
            i += 1
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                true_nu, aerr_est = quad_nonparabolic(phi, alpha)
                nu = getattr(mod,'{fname}'.format(fname=fname))(phi, alpha)
            aerr = abs(nu-true_nu)
            
            rtol = max(abs(2*aerr/true_nu), abs(2*aerr_est/true_nu))
            
            suppress_warnings = (rtol > 2e-7 or
                                 alpha >= 0.075 and phi >= 10 or
                                 alpha >= 0.15 and phi >= 5 or
                                 phi >= 40)
            
            # scalar
            f.write('\n')
            f.write('    def test_{fname}_{i}(self):\n'.format(fname=fname,i=i))
            f.write('        phi = {}\n'.format(phi))
            f.write('        alpha = {}\n'.format(alpha))
            if suppress_warnings:
                f.write('        with warnings.catch_warnings():\n')
                f.write('            warnings.simplefilter("ignore")\n    ')
            f.write('        nu = {modname}.{fname}(phi, alpha)\n'
                    .format(modname=modname, fname=fname))
            f.write('        true_nu = {}\n'
                    .format(true_nu))
            f.write('        rtol = {:.0e}\n'.format(rtol))
            f.write('        self.assert_rtol(nu, true_nu, rtol)\n')
            # vector
            f.write('        vphi = numpy.zeros(2); vphi.fill(phi)\n')
            f.write('        valpha = numpy.zeros(2); valpha.fill(alpha)\n')
            if suppress_warnings:
                f.write('        with warnings.catch_warnings():\n')
                f.write('            warnings.simplefilter("ignore")\n    ')
            f.write('        vnu = {modname}.{fname}(vphi, valpha)\n'
                    .format(modname=modname, fname=fname))
            f.write('        vtrue_nu = numpy.zeros(2); vtrue_nu.fill(true_nu)\n')
            f.write('        vrtol = numpy.zeros(2); vrtol.fill(rtol)\n')
            f.write('        self.assert_all_rtol(vnu, vtrue_nu, vrtol)\n')
            # buffered vector
            if suppress_warnings:
                f.write('        with warnings.catch_warnings():\n')
                f.write('            warnings.simplefilter("ignore")\n    ')
            f.write('        vnu = numpy.zeros(2); {modname}.{fname}(vphi, valpha, vnu)\n'
                    .format(modname=modname, fname=fname))
            f.write('        self.assert_all_rtol(vnu, vtrue_nu, vrtol)\n')
 
    f.write('\n')
    f.write('if __name__ == "__main__":\n')
    f.write('    unittest.main()')
